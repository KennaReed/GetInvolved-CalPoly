{"version":3,"file":"use-file-picker.cjs.production.min.js","sources":["../src/useFilePicker.tsx"],"sourcesContent":["import { useEffect, useState } from 'react';\r\nimport { fromEvent, FileWithPath } from 'file-selector';\r\nimport { UseFilePickerConfig, FileContent, FilePickerReturnTypes, FileError, ReaderMethod } from './interfaces';\r\n\r\nfunction useFilePicker({ accept = '*', multiple = true, readAs = 'Text', minFileSize, maxFileSize }: UseFilePickerConfig): FilePickerReturnTypes {\r\n  const [files, setFiles] = useState<FileWithPath[]>([]);\r\n  const [filesContent, setFilesContent] = useState<FileContent[]>([]);\r\n  const [fileErrors, setFileErrors] = useState<FileError[]>([]);\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n\r\n  const openFileSelector = () => {\r\n    const fileExtensions = accept instanceof Array ? accept.join(',') : accept;\r\n    openFileDialog(fileExtensions, multiple, evt => {\r\n      fromEvent(evt).then(files => {\r\n        setFiles(files as FileWithPath[]);\r\n      });\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (files.length === 0) {\r\n      setFilesContent([]);\r\n      return;\r\n    }\r\n    setLoading(true);\r\n    const filePromises = files.map(\r\n      (file: FileWithPath) =>\r\n        new Promise((resolve: (fileContent: FileContent) => void, reject: (reason: FileError) => void) => {\r\n          const reader = new FileReader();\r\n\r\n          //availible reader methods: readAsText, readAsBinaryString, readAsArrayBuffer, readAsDataURL\r\n          const readStrategy = reader[`readAs${readAs}` as ReaderMethod] as typeof reader.readAsText;\r\n          readStrategy.call(reader, file);\r\n\r\n          reader.onload = () => {\r\n            if (minFileSize) {\r\n              const minBytes = minFileSize * BYTES_PER_MEGABYTE;\r\n              if (file.size < minBytes) {\r\n                addError({ fileSizeTooSmall: true });\r\n              }\r\n            }\r\n            if (maxFileSize) {\r\n              const maxBytes = maxFileSize * BYTES_PER_MEGABYTE;\r\n              if (file.size > maxBytes) {\r\n                addError({ fileSizeToolarge: true });\r\n              }\r\n            }\r\n\r\n            resolve({\r\n              content: reader.result as string,\r\n              name: file.name,\r\n              lastModified: file.lastModified,\r\n            } as FileContent);\r\n          };\r\n\r\n          reader.onerror = () => {\r\n            addError({ readerError: reader.error });\r\n          };\r\n\r\n          const addError = ({ name = file.name, ...others }: FileError) => {\r\n            reject({ name, fileSizeToolarge: false, fileSizeTooSmall: false, ...others });\r\n          };\r\n        })\r\n    );\r\n    Promise.all(filePromises)\r\n      .then((fileContent: FileContent[]) => {\r\n        setFilesContent(fileContent);\r\n        setFileErrors([]);\r\n      })\r\n      .catch(err => {\r\n        setFileErrors(f => [err, ...f]);\r\n      })\r\n      .finally(() => setLoading(false));\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [files]);\r\n\r\n  return [filesContent, fileErrors, openFileSelector, loading];\r\n}\r\n\r\nexport default useFilePicker;\r\n\r\nfunction openFileDialog(accept: string, multiple: boolean, callback: (arg: any) => void) {\r\n  // this function must be called from  a user\r\n  // activation event (ie an onclick event)\r\n\r\n  // Create an input element\r\n  var inputElement = document.createElement('input');\r\n  // Set its type to file\r\n  inputElement.type = 'file';\r\n  // Set accept to the file types you want the user to select.\r\n  // Include both the file extension and the mime type\r\n  inputElement.accept = accept;\r\n  // Accept multiple files\r\n  inputElement.multiple = multiple;\r\n  // set onchange event to call callback when user has selected file\r\n  inputElement.addEventListener('change', callback);\r\n  // dispatch a click event to open the file dialog\r\n  inputElement.dispatchEvent(new MouseEvent('click'));\r\n}\r\n\r\n//Const values\r\nconst BYTES_PER_MEGABYTE = 1000000;\r\n"],"names":["accept","multiple","readAs","minFileSize","maxFileSize","useState","files","setFiles","filesContent","setFilesContent","fileErrors","setFileErrors","loading","setLoading","useEffect","length","filePromises","map","file","Promise","resolve","reject","reader","FileReader","call","onload","size","addError","fileSizeTooSmall","fileSizeToolarge","content","result","name","lastModified","onerror","readerError","error","others","all","then","fileContent","err","f","callback","inputElement","document","createElement","type","addEventListener","evt","fromEvent","dispatchEvent","MouseEvent","openFileDialog","Array","join"],"mappings":"2VAIA,oBAAyBA,OAAAA,aAAS,UAAKC,SAAAA,oBAAiBC,OAAAA,aAAS,SAAQC,IAAAA,YAAaC,IAAAA,cAC1DC,WAAyB,IAA5CC,OAAOC,SAC0BF,WAAwB,IAAzDG,OAAcC,SACeJ,WAAsB,IAAnDK,OAAYC,SACWN,YAAkB,GAAzCO,OAASC,cAWhBC,aAAU,cACa,IAAjBR,EAAMS,QAIVF,GAAW,OACLG,EAAeV,EAAMW,KACzB,SAACC,UACC,IAAIC,SAAQ,SAACC,EAA6CC,OAClDC,EAAS,IAAIC,WAGED,WAAgBpB,GACxBsB,KAAKF,EAAQJ,GAE1BI,EAAOG,OAAS,WACVtB,GAEEe,EAAKQ,KAgEI,IAjEIvB,GAEfwB,EAAS,CAAEC,kBAAkB,IAG7BxB,GAEEc,EAAKQ,KA0DI,IA3DItB,GAEfuB,EAAS,CAAEE,kBAAkB,IAIjCT,EAAQ,CACNU,QAASR,EAAOS,OAChBC,KAAMd,EAAKc,KACXC,aAAcf,EAAKe,gBAIvBX,EAAOY,QAAU,WACfP,EAAS,CAAEQ,YAAab,EAAOc,aAG3BT,EAAW,oBAAGK,KAAAA,aAAOd,EAAKc,OAASK,iJACvChB,KAASW,KAAAA,EAAMH,kBAAkB,EAAOD,kBAAkB,GAAUS,WAI5ElB,QAAQmB,IAAItB,GACTuB,MAAK,SAACC,GACL/B,EAAgB+B,GAChB7B,EAAc,cAET,SAAA8B,GACL9B,GAAc,SAAA+B,UAAMD,UAAQC,kBAErB,kBAAM7B,GAAW,WAnD1BJ,EAAgB,MAqDjB,CAACH,IAEG,CAACE,EAAcE,EAlEG,YAuE3B,SAAwBV,EAAgBC,EAAmB0C,OAKrDC,EAAeC,SAASC,cAAc,SAE1CF,EAAaG,KAAO,OAGpBH,EAAa5C,OAASA,EAEtB4C,EAAa3C,SAAWA,EAExB2C,EAAaI,iBAAiB,UAnFa,SAAAC,GACvCC,YAAUD,GAAKV,MAAK,SAAAjC,GAClBC,EAASD,SAmFfsC,EAAaO,cAAc,IAAIC,WAAW,UArFxCC,CADuBrD,aAAkBsD,MAAQtD,EAAOuD,KAAK,KAAOvD,EACrCC,IAgEmBW"}